/**
 * Pre-computed Recommendations API
 * Phase 1: Serves recommendations generated by background job
 * 
 * This endpoint provides instant dashboard loading by serving
 * recommendations that were pre-computed by the background job.
 */

import { withSupabase, withError, ok, fail } from '@/lib/api/factory'
import { logger } from '@/lib/logger'

export const GET = withError(
  withSupabase(async ({ request, supabase }) => {
    try {
      const url = new URL(request.url)
      const limit = parseInt(url.searchParams.get('limit') || '12')
      const includeInsights = url.searchParams.get('includeInsights') === 'true'
      
      // Get current user - try from Authorization header first, then cookies
      let user = null
      let authError = null

      // Check for Authorization header
      const authHeader = request.headers.get('Authorization')
      if (authHeader && authHeader.startsWith('Bearer ')) {
        const token = authHeader.replace('Bearer ', '')
        const { data, error } = await supabase.auth.getUser(token)
        user = data.user
        authError = error
      } else {
        // Fallback to cookie-based auth
        const { data, error } = await supabase.auth.getUser()
        user = data.user
        authError = error
      }
      
      if (authError || !user) {
        return fail('Unauthorized', 401)
      }

      logger.info('Fetching pre-computed recommendations', {
        userId: user.id,
        limit,
        includeInsights
      })

      // Fetch pre-computed recommendations with movie details
      const { data: recommendations, error: recError } = await supabase
        .from('recommendations')
        .select(`
          *,
          movies:movie_id (
            id,
            title,
            year,
            genre,
            director,
            plot,
            poster_url,
            rating,
            runtime
          )
        `)
        .eq('user_id', user.id)
        .order('confidence', { ascending: false })
        .order('generated_at', { ascending: false })
        .limit(limit)

      if (recError) {
        logger.error('Failed to fetch recommendations', { error: recError.message })
        return fail('Failed to fetch recommendations', 500)
      }

      // If no pre-computed recommendations, trigger background job and return fallback
      if (!recommendations || recommendations.length === 0) {
        console.log('No pre-computed recommendations found, getting fallback')
        logger.info('No pre-computed recommendations found, triggering background job')
        
        // Queue recommendation refresh for this user
        await queueRecommendationRefresh(user.id, 'manual_refresh')
        
        // Return fallback recommendations
        const fallbackRecs = await getFallbackRecommendations(user.id, limit)
        
        // Always return a fallback response, even if no recommendations are found
        return ok({
          recommendations: fallbackRecs,
          total: fallbackRecs.length,
          source: 'fallback',
          message: fallbackRecs.length > 0 
            ? 'Generating personalized recommendations in background. Please check back in a few minutes.'
            : 'No recommendations available yet. Customize the settings below to help us understand your preferences better.',
          refreshTriggered: true,
          meta: {
            generatedAt: new Date().toISOString(),
            analysisSource: 'fallback',
            discoverySource: 'popular',
            isStale: false
          }
        })
      }

      // Process recommendations for response
      const processedRecs = recommendations.map(rec => ({
        id: rec.id,
        movie: rec.movies,
        score: rec.score,
        confidence: rec.confidence,
        reason: rec.reason,
        discoverySource: rec.discovery_source,
        analysisSource: rec.analysis_source || 'standard',
        generatedAt: rec.generated_at,
        enhancedAt: rec.enhanced_at,
        ...(includeInsights && rec.ai_insights && {
          insights: rec.ai_insights
        })
      }))

      // Get metadata about the recommendations
      const latestGeneration = recommendations[0]?.generated_at
      // Simplified analysis source counting to avoid TypeScript complexity
      const totalSources = recommendations.length
      const analysisSourceCounts = { total: totalSources }

      // Check if recommendations are stale (older than 6 hours)
      const isStale = latestGeneration && 
        (Date.now() - new Date(latestGeneration).getTime()) > (6 * 60 * 60 * 1000)

      if (isStale) {
        // Trigger background refresh for stale recommendations
        await queueRecommendationRefresh(user.id, 'scheduled')
      }

      logger.info('Successfully served pre-computed recommendations', {
        count: processedRecs.length,
        latestGeneration,
        analysisSourceCounts,
        isStale
      })

      return ok({
        recommendations: processedRecs,
        total: processedRecs.length,
        source: 'precomputed',
        meta: {
          generatedAt: latestGeneration,
          analysisSourceBreakdown: analysisSourceCounts,
          isStale,
          refreshTriggered: isStale
        }
      })

    } catch (error) {
      logger.error('Error in precomputed recommendations endpoint', { 
        error: error instanceof Error ? error.message : String(error) 
      })
      return fail('Internal server error', 500)
    }
  })
)

/**
 * Queue a recommendation refresh for the user
 */
async function queueRecommendationRefresh(userId: string, triggerType: string) {
  try {
    // Initialize Supabase client for internal functions
    const { createClient } = await import('@supabase/supabase-js')
    const { getSupabaseUrl, getSupabaseServiceRoleKey } = await import('@/lib/env')
    
    const serviceRoleKey = getSupabaseServiceRoleKey()
    if (!serviceRoleKey) {
      logger.warn('Service role key not available for queueing refresh')
      return
    }
    
    const supabase = createClient(getSupabaseUrl(), serviceRoleKey)
    
    // Use the database function we created in the migration
    const { error } = await supabase.rpc('queue_recommendation_refresh', {
      p_user_id: userId,
      p_trigger_type: triggerType,
      p_priority: triggerType === 'manual_refresh' ? 3 : 5 // Higher priority for manual
    })

    if (error) {
      logger.warn('Failed to queue recommendation refresh', { error: error.message })
    }
  } catch (error) {
    logger.warn('Error queueing recommendation refresh', { 
      error: error instanceof Error ? error.message : String(error) 
    })
  }
}

/**
 * Get fallback recommendations when no pre-computed ones exist
 */
async function getFallbackRecommendations(userId: string, limit: number) {
  try {
    // Initialize Supabase client for internal functions  
    const { createClient } = await import('@supabase/supabase-js')
    const { getSupabaseUrl, getSupabaseServiceRoleKey } = await import('@/lib/env')
    
    const serviceRoleKey = getSupabaseServiceRoleKey()
    if (!serviceRoleKey) {
      logger.warn('Service role key not available for fallback recommendations')
      return []
    }
    
    const supabase = createClient(getSupabaseUrl(), serviceRoleKey)
    
    try {
      // First try to use the stored procedure if it exists
      const { data: fallbackMovies } = await supabase
        .rpc('generate_simple_recommendations', {
          p_user_id: userId,
          p_limit: limit
        })

      if (fallbackMovies && fallbackMovies.length > 0) {
        return fallbackMovies.map((movie: any) => ({
          id: `fallback-${movie.id}`,
          movie: {
            id: movie.id,
            title: movie.title || 'Unknown Title',
            year: movie.year || new Date().getFullYear(),
            genre: movie.genre || ['Drama'],
            director: movie.director || ['Unknown Director'],
            plot: movie.plot || 'No plot available',
            poster_url: movie.poster_url,
            rating: movie.rating || 7.0,
            runtime: movie.runtime || 120
          },
          score: movie.recommendation_score || 0.7,
          confidence: 0.6,
          reason: 'Popular movie you might enjoy',
          discoverySource: 'popular',
          analysisSource: 'fallback',
          generatedAt: new Date().toISOString()
        }))
      }
    } catch (rpcError) {
      logger.warn('Stored procedure not available, using basic fallback', { error: rpcError })
    }

    // Fallback to basic popular movies query if stored procedure fails
    const { data: basicMovies, error: basicError } = await supabase
      .from('movies')
      .select('*')
      .gt('rating', 7.0)
      .not('genre', 'is', null)
      .order('rating', { ascending: false })
      .limit(limit)

    if (!basicMovies) return []

    return basicMovies.map((movie: any) => ({
      id: `fallback-${movie.id}`,
      movie: {
        id: movie.id,
        title: movie.title || 'Unknown Title',
        year: movie.year || new Date().getFullYear(),
        genre: movie.genre || ['Drama'],
        director: movie.director || ['Unknown Director'],
        plot: movie.plot || 'No plot available',
        poster_url: movie.poster_url,
        rating: movie.rating || 7.0,
        runtime: movie.runtime || 120
      },
      score: (movie.rating || 7.0) / 10,
      confidence: 0.5,
      reason: 'Highly rated movie',
      discoverySource: 'popular',
      analysisSource: 'fallback',
      generatedAt: new Date().toISOString()
    }))

  } catch (error) {
    logger.error('Failed to get fallback recommendations', { 
      error: error instanceof Error ? error.message : String(error) 
    })
    return []
  }
}

