/**
 * Pre-computed Recommendations API
 * Phase 1: Serves recommendations generated by background job
 * 
 * This endpoint provides instant dashboard loading by serving
 * recommendations that were pre-computed by the background job.
 */

import { withSupabase, withError, ok, fail } from '@/lib/api/factory'
import { logger } from '@/lib/logger'

export const GET = withError(
  withSupabase(async ({ request, supabase }) => {
    try {
      const url = new URL(request.url)
      const limit = parseInt(url.searchParams.get('limit') || '12')
      const includeInsights = url.searchParams.get('includeInsights') === 'true'
      
      // Get current user - try from Authorization header first, then cookies
      let user = null
      let authError = null

      // Check for Authorization header
      const authHeader = request.headers.get('Authorization')
      if (authHeader && authHeader.startsWith('Bearer ')) {
        const token = authHeader.replace('Bearer ', '')
        const { data, error } = await supabase.auth.getUser(token)
        user = data.user
        authError = error
      } else {
        // Fallback to cookie-based auth
        const { data, error } = await supabase.auth.getUser()
        user = data.user
        authError = error
      }
      
      if (authError || !user) {
        return fail('Unauthorized', 401)
      }

      logger.info('Fetching pre-computed recommendations', {
        userId: user.id,
        limit,
        includeInsights
      })

      // Use the enhanced simple recommendations function directly
      logger.info('Using generate_simple_recommendations function for user recommendations')
      
      const { data: simpleRecs, error: simpleError } = await supabase
        .rpc('generate_simple_recommendations', {
          p_user_id: user.id,
          p_limit: limit
        })

      if (simpleError) {
        logger.error('Simple recommendations function failed, using fallback', { error: simpleError.message })
        
        // Fallback to our existing fallback system
        const fallbackRecs = await getFallbackRecommendations(user.id, limit)
        
        return ok({
          recommendations: fallbackRecs,
          total: fallbackRecs.length,
          source: 'fallback',
          message: fallbackRecs.length > 0 
            ? 'Smart recommendations in progress. Showing popular movies based on your taste.'
            : 'No recommendations available yet. Rate more movies to help us understand your preferences better.',
          refreshTriggered: false,
          meta: {
            generatedAt: new Date().toISOString(),
            analysisSource: 'fallback',
            discoverySource: 'popular',
            isStale: false
          }
        })
      }

      // Transform simple recommendations to expected format
      const recommendations = (simpleRecs || []).map((movie: any) => ({
        id: `smart-${movie.id}`,
        movies: {
          id: movie.id,
          title: movie.title || 'Unknown Title',
          year: movie.year || new Date().getFullYear(),
          genre: movie.genre || ['Drama'],
          director: movie.director || ['Unknown Director'],
          plot: movie.plot || 'No plot available',
          poster_url: movie.poster_url,
          rating: movie.rating || 7.0,
          runtime: movie.runtime || 120
        },
        score: movie.recommendation_score || 0.7,
        confidence: 0.85, // High confidence for personalized recommendations
        reason: 'Recommended based on your viewing preferences and rating history',
        discovery_source: 'personalized',
        analysis_source: 'smart-algorithm',
        generated_at: new Date().toISOString(),
        enhanced_at: null,
        ai_insights: null
      }))

      // Process recommendations for response
      const processedRecs = recommendations.map(rec => ({
        id: rec.id,
        movie: rec.movies,
        score: rec.score,
        confidence: rec.confidence,
        reason: rec.reason,
        discoverySource: rec.discovery_source,
        analysisSource: rec.analysis_source || 'smart-algorithm',
        generatedAt: rec.generated_at,
        enhancedAt: rec.enhanced_at,
        ...(includeInsights && rec.ai_insights ? {
          insights: rec.ai_insights
        } : {})
      }))

      // Get metadata about the recommendations
      const latestGeneration = new Date().toISOString()
      const totalSources = recommendations.length
      const analysisSourceCounts = { total: totalSources }

      logger.info('Successfully served smart recommendations', {
        count: processedRecs.length,
        source: 'smart-algorithm',
        latestGeneration
      })

      return ok({
        recommendations: processedRecs,
        total: processedRecs.length,
        source: 'smart-recommendations',
        message: processedRecs.length > 0 
          ? `Showing ${processedRecs.length} personalized recommendations based on your ${(await supabase.from('ratings').select('id').eq('user_id', user.id)).data?.length || 0} ratings`
          : 'Building your personalized recommendations...',
        meta: {
          generatedAt: latestGeneration,
          analysisSourceBreakdown: analysisSourceCounts,
          isStale: false,
          refreshTriggered: false
        }
      })

    } catch (error) {
      logger.error('Error in precomputed recommendations endpoint', { 
        error: error instanceof Error ? error.message : String(error) 
      })
      return fail('Internal server error', 500)
    }
  })
)


/**
 * Get fallback recommendations when no pre-computed ones exist
 * Uses different strategies based on user's rating history
 */
async function getFallbackRecommendations(userId: string, limit: number) {
  try {
    // Initialize Supabase client for internal functions  
    const { createClient } = await import('@supabase/supabase-js')
    const { getSupabaseUrl, getSupabaseServiceRoleKey } = await import('@/lib/env')
    
    const serviceRoleKey = getSupabaseServiceRoleKey()
    if (!serviceRoleKey) {
      logger.warn('Service role key not available for fallback recommendations')
      return []
    }
    
    const supabase = createClient(getSupabaseUrl(), serviceRoleKey)
    
    // Check how many movies the user has rated
    const { data: userRatings, error: ratingsError } = await supabase
      .from('ratings')
      .select('movie_id, rating, interested')
      .eq('user_id', userId)
    
    const ratingCount = userRatings?.length || 0
    logger.info(`User has ${ratingCount} ratings, using appropriate recommendation strategy`)
    
    // For users with significant rating history (5+), use personalized recommendations
    if (ratingCount >= 5 && userRatings) {
      try {
        const personalizedRecs = await getPersonalizedRecommendations(supabase, userId, userRatings, limit)
        if (personalizedRecs.length > 0) {
          return personalizedRecs
        }
      } catch (error) {
        logger.warn('Personalized recommendations failed, falling back to basic', { error })
      }
    }
    
    // For new users or fallback, use trending/popular movies
    try {
      // Try the stored procedure for basic recommendations
      const { data: fallbackMovies } = await supabase
        .rpc('generate_simple_recommendations', {
          p_user_id: userId,
          p_limit: limit
        })

      if (fallbackMovies && fallbackMovies.length > 0) {
        const analysisSource = ratingCount >= 5 ? 'fallback-experienced' : 'trending-new-user'
        const reason = ratingCount >= 5 ? 'Popular movie in your preferred genres' : 'Trending movie perfect for discovering your taste'
        
        return fallbackMovies.map((movie: any) => ({
          id: `fallback-${movie.id}`,
          movie: {
            id: movie.id,
            title: movie.title || 'Unknown Title',
            year: movie.year || new Date().getFullYear(),
            genre: movie.genre || ['Drama'],
            director: movie.director || ['Unknown Director'],
            plot: movie.plot || 'No plot available',
            poster_url: movie.poster_url,
            rating: movie.rating || 7.0,
            runtime: movie.runtime || 120
          },
          score: movie.recommendation_score || 0.7,
          confidence: ratingCount >= 5 ? 0.6 : 0.8, // Higher confidence for trending to new users
          reason,
          discoverySource: ratingCount >= 5 ? 'genre-popular' : 'trending',
          analysisSource,
          generatedAt: new Date().toISOString()
        }))
      }
    } catch (rpcError) {
      logger.warn('Stored procedure not available, using basic fallback', { error: rpcError })
    }

    // Fallback to basic popular movies query if stored procedure fails
    const { data: basicMovies } = await supabase
      .from('movies')
      .select('*')
      .gt('rating', 7.0)
      .not('genre', 'is', null)
      .order('rating', { ascending: false })
      .limit(limit)

    if (!basicMovies) return []

    return basicMovies.map((movie: any) => ({
      id: `fallback-${movie.id}`,
      movie: {
        id: movie.id,
        title: movie.title || 'Unknown Title',
        year: movie.year || new Date().getFullYear(),
        genre: movie.genre || ['Drama'],
        director: movie.director || ['Unknown Director'],
        plot: movie.plot || 'No plot available',
        poster_url: movie.poster_url,
        rating: movie.rating || 7.0,
        runtime: movie.runtime || 120
      },
      score: (movie.rating || 7.0) / 10,
      confidence: 0.5,
      reason: 'Highly rated movie',
      discoverySource: 'popular',
      analysisSource: 'fallback',
      generatedAt: new Date().toISOString()
    }))

  } catch (error) {
    logger.error('Failed to get fallback recommendations', { 
      error: error instanceof Error ? error.message : String(error) 
    })
    return []
  }
}

/**
 * Generate personalized recommendations based on user's rating history
 */
async function getPersonalizedRecommendations(supabase: any, userId: string, userRatings: any[], limit: number) {
  // Analyze user's preferences from their ratings
  const likedMovies = userRatings.filter(r => r.rating >= 3 && r.interested)
  const dislikedMovies = userRatings.filter(r => r.rating <= 2 || !r.interested)
  
  // Get movie details for liked movies to analyze genres
  const { data: likedMovieDetails } = await supabase
    .from('movies')
    .select('id, title, genre, director, year, rating')
    .in('id', likedMovies.map(r => r.movie_id))
  
  if (!likedMovieDetails || likedMovieDetails.length === 0) {
    return []
  }
  
  // Calculate genre preferences
  const genreScores = new Map<string, number>()
  const directorScores = new Map<string, number>()
  
  likedMovieDetails.forEach((movie: any) => {
    const userRating = userRatings.find(r => r.movie_id === movie.id)?.rating || 3
    const weight = userRating / 4 // Normalize to 0-1
    
    // Weight genres by how much user liked movies in that genre
    movie.genre?.forEach((genre: string) => {
      genreScores.set(genre, (genreScores.get(genre) || 0) + weight)
    })
    
    // Weight directors similarly
    movie.director?.forEach((director: string) => {
      directorScores.set(director, (directorScores.get(director) || 0) + weight)
    })
  })
  
  // Get top preferred genres
  const topGenres = Array.from(genreScores.entries())
    .sort((a, b) => b[1] - a[1])
    .slice(0, 5)
    .map(([genre]) => genre)
  
  // Get top directors
  const topDirectors = Array.from(directorScores.entries())
    .sort((a, b) => b[1] - a[1])
    .slice(0, 3)
    .map(([director]) => director)
  
  // Find movies that match user preferences but haven't been rated
  const { data: recommendedMovies } = await supabase
    .from('movies')
    .select('*')
    .overlaps('genre', topGenres)
    .not('id', 'in', `(${userRatings.map(r => `'${r.movie_id}'`).join(',')})`)
    .gte('rating', 6.5) // Only recommend well-rated movies
    .order('rating', { ascending: false })
    .limit(limit * 2) // Get more to filter and rank
  
  if (!recommendedMovies) {
    return []
  }
  
  // Score movies based on how well they match user preferences
  const scoredMovies = recommendedMovies.map((movie: any) => {
    let score = movie.rating / 10 // Base score from movie rating
    
    // Bonus for preferred genres
    const genreMatches = movie.genre?.filter((g: string) => topGenres.includes(g)).length || 0
    score += genreMatches * 0.15
    
    // Bonus for preferred directors
    const directorMatches = movie.director?.filter((d: string) => topDirectors.includes(d)).length || 0
    score += directorMatches * 0.1
    
    // Prefer newer movies slightly
    const currentYear = new Date().getFullYear()
    if (movie.year && movie.year >= currentYear - 5) {
      score += 0.05
    }
    
    return {
      ...movie,
      personalizedScore: Math.min(score, 1.0) // Cap at 1.0
    }
  })
  
  // Sort by personalized score and take top recommendations
  const topRecommendations = scoredMovies
    .sort((a: any, b: any) => b.personalizedScore - a.personalizedScore)
    .slice(0, limit)
  
  // Format for response
  return topRecommendations.map((movie: any) => {
    const matchedGenres = movie.genre?.filter((g: string) => topGenres.includes(g)) || []
    const matchedDirectors = movie.director?.filter((d: string) => topDirectors.includes(d)) || []
    
    let reason = `Based on your love for ${matchedGenres.slice(0, 2).join(' and ')} movies`
    if (matchedDirectors.length > 0) {
      reason += ` and films by ${matchedDirectors[0]}`
    }
    
    return {
      id: `personalized-${movie.id}`,
      movie: {
        id: movie.id,
        title: movie.title || 'Unknown Title',
        year: movie.year || new Date().getFullYear(),
        genre: movie.genre || [],
        director: movie.director || [],
        plot: movie.plot || 'No plot available',
        poster_url: movie.poster_url,
        rating: movie.rating || 7.0,
        runtime: movie.runtime || 120
      },
      score: movie.personalizedScore,
      confidence: 0.85,
      reason,
      discoverySource: 'personalized',
      analysisSource: 'user-preferences',
      generatedAt: new Date().toISOString()
    }
  })
}

